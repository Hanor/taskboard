<!--
  [LICENSE]
  Taskboard
  ---
  Copyright (C) 2015 - 2016 Objective Solutions
  ---
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  [/LICENSE]
  -->
<dom-module id="widget-cfd">

    <template>

        <style>
        </style>

        <widget-wrap title="CFD" is-ready="{{isReady}}" tags="{{tags}}" options="{{options}}" chart="{{chart}}" error-message="{{errorMessage}}">

            <div id="cfd" title="Double click to enter selection mode" class="tb-chart"></div>

            <wrap-modal title="Filters" class="filters-modal">
                <h3 class="tb-label">Issue Types</h3>
                <div class="config-slot-0 dc-chart--no-float"></div>
                <div class="modal-footer">
                    <paper-button class="colorful" raised title="OK" on-tap="_closeFiltersModal">OK</paper-button>
                </div>
            </wrap-modal>

        </widget-wrap>

        <wrap-modal title="Settings" class="settings-modal">
            <h3 class="tb-label">Level</h3>
            <div>
                <label id="labelLevel"></label>
                <paper-radio-group class="radio-group" selected="{{settingLevel}}" aria-labelledby="labelLevel">
                    <paper-radio-button name="Demand">Demand</paper-radio-button>
                    <paper-radio-button name="Feature">Feature</paper-radio-button>
                    <paper-radio-button name="Subtask">Subtask</paper-radio-button>
                </paper-radio-group>
            </div>
            <div class="modal-footer">
                <paper-button class="colorful" raised title="Save" on-tap="_saveSettings">Save</paper-button>
            </div>
        </wrap-modal>

    </template>

    <script>
        (function () {
            Polymer({
                is: 'widget-cfd',

                properties: {
                    selectedProjectKey: {
                        type: String,
                        notify: true
                    },
                    selectedDate: {
                        type: String,
                        notify: true,
                        value: ''
                    },
                    isReady: {
                        type: Boolean,
                        notify: true,
                        value: false
                    },
                    errorMessage: {
                        type: String,
                        notify: true,
                        value: ''
                    },
                    chart: {
                        type: Object,
                        notify: true,
                        value: function() { return {}; }
                    },
                    tags: {
                        type: Array
                    },
                    options: {
                        type: Array,
                        readOnly: true
                    },
                    settingLevel: {
                        type: String,
                        notify: true,
                        value: 'Subtask'
                    }
                },

                observers: [
                    '_onProjectSelected(selectedProjectKey, selectedDate)'
                ],

                ready: function() {
                    this._setOptions([
                        {
                            icon:'taskboard-icons:dashboard-view-mode'
                            , title: 'Toggle View/Selection mode'
                            , tap: this.toggleSelectionViewMode.bind(this)
                            , cssClasses: ''
                        },
                        {
                            icon:'taskboard-icons:dashboard-filter'
                            , title: 'Filters'
                            , tap: this._openFiltersModal.bind(this)
                            , hidden: true
                        },
                        {
                            icon: 'taskboard-icons:settings'
                            , title: 'Settings'
                            , tap: this._openSettingsModal.bind(this)
                            , cssClasses: ''
                        }
                    ]);
                    this.widgetList = [];
                },

                _onProjectSelected: function() {
                    this.loadCfdChart();
                },

                groupByDate: function(cfdData) {
                    var status = Object.keys(cfdData.dataByStatus).reverse();
                    var graphData = [];
                    // regroup based on date
                    status.forEach(function(stat) {
                        cfdData.dataByStatus[stat].forEach(function(d) {
                            graphData.push({
                                date: new Date(d.date),
                                status: stat,
                                count: d.count,
                                issueType: d.type
                            });
                        })
                    });

                    return graphData;
                },

                loadCfdChart: function() {
                    this.reset();

                    var self = this;

                    var savedLevel = self._getSavedLevel();
                    self.set('tags', [savedLevel]);
                    self.xhr = d3.json("/api/projects/"+ self.selectedProjectKey + "/followup/cfd?level=" + savedLevel, function(error, cfdData) {
                        if(self.handleErrors(error, cfdData))
                            return;

                        var status = Object.keys(cfdData.dataByStatus).reverse();

                        self.cfdData = self.groupByDate(cfdData);
                        var startDate = self.cfdData[0].date;
                        var endDate = self.cfdData[self.cfdData.length-1].date;

                        self.ndx = crossfilter(self.cfdData);
                        // the (run) dimension is the dimension on which dc will iterate and will become the "X" axis
                        self.cfdDim = self.ndx.dimension(function(d) {
                            return d.date;
                        });

                        function compose(p, v, signal){
                            if (!p.plotData)
                                p.plotData = {}

                            if (!p.plotData[v.status])
                                p.plotData[v.status] = 0;

                            p.plotData[v.status] += signal * v.count;
                            return p;
                        }

                        self.cfdGroup = self.cfdDim.group()
                            .reduce(function(p, v) {
                                    return compose(p, v, 1)
                                },
                                function(p, v) {
                                    return compose(p, v, -1)
                                },
                                function() {
                                    return {plotData:{}};
                                }
                            );

                        self.createChart(startDate, endDate);
                        self.createIssueListFilter();

                        // function to access correct data for each stack
                        function stackAccessor(status) {
                            return function(d) {
                                return d.value.plotData[status];
                            };
                        }

                        var xScale = d3.time.scale().domain([startDate, endDate]);
                        self.chart
                            .dimension(self.cfdDim)
                            .group(self.cfdGroup, status[0], stackAccessor(status[0])) // the first stack must be added as a group
                            .x(xScale);

                        status.forEach(function(stat) {
                            // stackTitle(stat) generates a callback to generate the label for points in this stack
                            self.chart.title(stat, function (d){
                                var label = d.key.toLocaleDateString() + "\n\n";
                                var total = 0;
                                label +="** " + stat +": "+d.value.plotData[stat]+ " **\n";
                                Object.keys(d.value.plotData).reverse().forEach(function(key) {
                                    if (key !== stat)
                                        label += key+": "+d.value.plotData[key]+ "\n";
                                    total += d.value.plotData[key];
                                });
                                return label+="\nTotal: " + total;
                            });
                        });

                        // remove the first status because it was already added in the "group" invocation above
                        status = status.splice(1);

                        // add the other stacks, one for each remaining status
                        status.forEach(function(stat) {
                            // stack the status data; stackAccessor(stat) generates a callback that tells dc how to read this stack data
                            self.chart.stack(self.cfdGroup, stat, stackAccessor(stat))
                        });

                        self.chart.__legendables = self.chart.legendables;
                        self.chart.legendables = function() {
                            var items = self.chart.__legendables();
                            return items.reverse();
                        };

                        self.chart.render();

                        self.isReady = true;
                    });
                },

                reset: function() {
                    this.set('isReady', false);
                    this.set('errorMessage', '');
                    this.set('options.1.cssClasses', '');
                    this.set('options.1.hidden', true);

                    if (this.xhr) {
                        this.xhr.abort();
                        this.xhr = null;
                    }
                    if (!_.isEmpty(this.chart)) {
                        dc.deregisterChart(this.chart);
                        this.set('chart', {});
                    }
                    if (this.issueListFilter) {
                        dc.deregisterChart(this.issueListFilter);
                        delete this.issueListFilter;
                    }
                },

                handleErrors: function(error, cfdData) {
                    if(error) {
                        this.set('errorMessage', error.message);
                        return true;
                    }
                    if(!Object.keys(cfdData.dataByStatus).length) {
                        this.set('errorMessage', 'Impossible to generate CFD. No data for this project.');
                        return true;
                    }

                    return false;
                },

                createChart: function(startDate, endDate) {
                    var self = this;
                    var chart = dc.lineChart("#cfd");

                    // basic chart configuration
                    chart
                        .margins({top: 20, right: 30, bottom: 60, left: 200})
                        .legend(
                            dcUtils.getDefaultLegend()
                        )
                        .colors(
                            dcUtils.getDefaultColors()
                        )
                        .renderArea(true)
                        .brushOn(false)       // don't select with drag-n-drop
                        .mouseZoomable(false)  // zoom with mouse wheel
                        .elasticY(true)       // y axis will adjust to the data

                    setupChartDateTicks(chart, startDate, endDate, 14);

                    dcUtils.rotateDateFormattedXAxis(chart);

                    chart.addChartWidget = function(c){
                        self.widgetList.push(c)
                    }

                    var brushOnDelegate = chart.brushOn;
                    chart.brushOn = function(state) {
                        if (arguments.length > 0) {
                            self.setupViewMode(state);
                            return brushOnDelegate(state);
                        }

                        return brushOnDelegate();
                    }

                    chart.on('filtered', this.setupSelector.bind(this));
                    
                    $("#cfd").dblclick(this.toggleSelectionViewMode.bind(this));

                    this.set('chart', chart);
                    this.fire("iron-signal", {name:"cfd-created", data:{
                        cfdChartInstance: chart
                    }})
                    this.needsSetup = true;
                    this.startDate = startDate;
                    this.endDate = endDate;
                    this.setupViewMode(false);
                },

                toggleSelectionViewMode: function() {
                    if (this.needsSetup) {
                        this.needsSetup = false;
                        var timeSpan = this.endDate - this.startDate;
                        var filterStart = new Date(this.startDate.getTime() + timeSpan/3)
                        var filterEnd   = new Date(this.endDate.getTime() - timeSpan/3)
                        this.chart.filter([filterStart, filterEnd])
                    }

                    this.chart.brushOn(!this.chart.brushOn());
                    this.chart.render();
                    this.setupSelector(this.chart)
                },
                
                setupViewMode: function(state) {
                    if (state) {
                        $("#cfd").prop("title", "Double click to go back to view mode")
                        this.set('options.0.cssClasses', 'widget__button_highlighted');
                    }
                    else { 
                        $("#cfd").prop("title", "Double click to enter selection mode")
                        this.set('options.0.cssClasses', '');
                    }
                },
                
                setupSelector: function(rangeChart) {
                    if (!rangeChart.filter() || !rangeChart.brushOn())
                        this.resetSelection(rangeChart)
                    else
                        this.applySelection(rangeChart);
                },

                applySelection: function(rangeChart) {
                    this.widgetList.forEach(function(w) {
                        var focusChart = w.chart;
                        if (!rangesEqual(rangeChart.filter(), focusChart.filter())) {
                            dc.events.trigger(function () {
                                focusChart.focus(rangeChart.filter());

                                var od = focusChart.xOriginalDomain();
                                // recalculate tick count so we have a better resolution of dates when focused
                                var tickCount = focusChart.visibleTickCount * ((od[od.length-1] - od[0])/ 
                                         (rangeChart.filter()[1]-rangeChart.filter()[0]));
                                tickCount = Math.round(tickCount);

                                if (focusChart.tickCount && focusChart.tickCount != tickCount) {
                                    focusChart
                                        .xAxis()
                                        .tickValues(dcUtils.getDateTicks(od[0], od[od.length-1], tickCount));
                                    focusChart.render();
                                }
                                focusChart.tickCount = tickCount;
                            });
                        }
                    });
                },

                resetSelection: function(rangeChart) {
                    var self = this;
                    var chart = this.chart;
                    dc.events.trigger(function () {
                        self.widgetList.forEach(function(w) {
                            var focusChart = w.chart;
                            var od = focusChart.xOriginalDomain();
                            focusChart.x().domain(od);
                            focusChart.focus([od[0], od[od.length-1]])
                            focusChart
                                .xAxis()
                                .tickValues(
                                    dcUtils.getDateTicks(od[0], od[od.length-1], 14)
                                );
                            focusChart.tickCount = 14;
                            focusChart.render();
                        });
                    });
                },

                createIssueListFilter: function() {
                    this.set('options.1.hidden', false);
                    var div = this.$$('.config-slot-0');
                    var list = dc.paperList(div);

                    this.typeDim = this.ndx.dimension(function(d) {
                        return d.issueType;
                    });
                    this.typeGroup = this.typeDim.group();

                    list
                        .dimension(this.typeDim)
                        .group(this.typeGroup)
                        .multiple(true)
                        .title(function(d) {
                            return d.key;
                        })
                        .promptValue('-none-')
                        .promptText('All Issues');

                    var all = list.data().map(list.keyAccessor());
                    list.replaceFilter([all]);

                    list.render();

                    var highlightButton = function() {
                        this.set('options.1.cssClasses', list.isAllSelected() ? '' : 'widget__button_highlighted');
                    }.bind(this);
                    list.on('filtered', highlightButton);

                    this.issueListFilter = list;
                },

                _openFiltersModal: function() {
                    this.$$('.filters-modal').open();
                },

                _closeFiltersModal: function() {
                    this.$$('.filters-modal').close();
                },

                _openSettingsModal: function() {
                    this.settingLevel = this._getSavedLevel();
                    this.$$('.settings-modal').open();
                },

                _saveSettings: function() {
                    var savedLevel = this._getSavedLevel();
                    if (savedLevel === this.settingLevel) {
                        this.$$('.settings-modal').close();
                        return;
                    }
                    localStorage.setItem("dashboard.cfd-chart." + this.selectedProjectKey + ".level", this.settingLevel);
                    this.$$('.settings-modal').close();
                    this.loadCfdChart();
                },

                _getSavedLevel: function() {
                    return localStorage.getItem("dashboard.cfd-chart." + this.selectedProjectKey + ".level") || "Subtask";
                }
            });
        })();
    </script>
</dom-module>