<!--
  [LICENSE]
  Taskboard
  ---
  Copyright (C) 2015 - 2016 Objective Solutions
  ---
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  [/LICENSE]
  -->
<dom-module id="widget-cfd">

    <template>

        <style>
            #cfd {
                max-height: 420px;
            }
        </style>

        <widget-wrap title="CFD" is-ready="{{isReady}}" chart="{{chart}}" error-message="{{errorMessage}}">

            <div id="cfd" class="tb-chart"></div>

        </widget-wrap>

    </template>

    <script>
        (function () {
            Polymer({
                is: 'widget-cfd',

                properties: {
                    selectedProjectKey: {
                        type: String,
                        notify: true
                    },
                    selectedDate: {
                        type: String,
                        notify: true,
                        value: '',
                    },
                    isReady: {
                        type: Boolean,
                        notify: true,
                        value: false
                    },
                    errorMessage: {
                        type: String,
                        notify: true,
                        value: ''
                    },
                    chart: {
                        type: Object,
                        notify: true,
                        value: function() { return {}; }
                    }
                },

                observers: [
                    '_onProjectSelected(selectedProjectKey, selectedDate)',
                ],

                ready: function() {
                },

                _onProjectSelected: function(selectedProjectKey, selectedDate) {
                    this.loadCfdChart(selectedProjectKey);
                },
                
                reduceCFDdata: function(cfdData) {
                	var status = Object.keys(cfdData.dataByStatus).reverse();
                    var graphData = {};
                    // reducing the data here, grouping by date
                    status.forEach(function(stat) { 
                        cfdData.dataByStatus[stat].forEach(function(d) {
                            d.date = new Date(d.date);
                            if (!graphData[d.date])
                                graphData[d.date] = {
                                    date: d.date,
                                    plotData: {}
                                };
                            if (!graphData[d.date].plotData[stat])
                                graphData[d.date].plotData[stat]=0;
                            graphData[d.date].plotData[stat] += d.count;
                        })
                    });
					// we don't need the keys, we want an array for crossfilter
                    return Object.values(graphData);
                },

                loadCfdChart: function(project) {
                    this.reset();

                    var self = this;
                    
                    d3.json("/api/projects/"+ project + "/followup/cfd", function(error, cfdData) {
                        if(self.handleErrors(error, cfdData))
                            return;

                        var status = Object.keys(cfdData.dataByStatus).reverse();

                        self.cfdData = self.reduceCFDdata(cfdData);
                        var minDate = self.cfdData[0].date;
                        var maxDate = self.cfdData[self.cfdData.length-1].date;
                        
                        self.ndx = crossfilter(self.cfdData);
                        // the (run) dimension is the dimension on which dc will iterate and will become the "X" axis
                        self.cfdDim = self.ndx.dimension(function(d) {
                            return d.date;
                        });
                        
                        self.cfdGroup = self.cfdDim.group()
                            .reduce(function(p, v) {
                                    return v; // we just keep the original data, because we reduced before
                                },
                                function(p, v) {
                                    return v;
                                },
                                function() {
                                    return {};
                                }
                            );
                        
                        self.createChart();
                        
                        // function to access correct data for each stack
                        function stackAccessor(status) { 
                            return function(d) {
                                return d.value.plotData[status];
                            };
                        }
                        
                        var xScale = d3.time.scale().domain([minDate, maxDate]);
                        self.chart
                            .dimension(self.cfdDim)
                            .group(self.cfdGroup, status[0], stackAccessor(status[0])) // the first stack must be added as a group
                            .x(xScale);

                        status.forEach(function(stat) {
                            // stackTitle(stat) generates a callback to generate the label for points in this stack
                            self.chart.title(stat, function (d){  
                                var label = d.key.toLocaleDateString() + "\n\n";
                                var total = 0;
                                label +="** " + stat +": "+d.value.plotData[stat]+ " **\n";
                                Object.keys(d.value.plotData).forEach(function(key) {
                                    if (key !== stat)
                                        label += key+": "+d.value.plotData[key]+ "\n";
                                    total += d.value.plotData[key];
                                });
                                return label+="\nTotal: " + total;
                            });
                        });
                        
                        // remove the first status because it was already added in the "group" invocation above
                        status = status.splice(1);
                        
                        // add the other stacks, one for each remaining status
                        status.forEach(function(stat) {
                        	// stack the status data; stackAccessor(stat) generates a callback that tells dc how to read this stack data
                            self.chart.stack(self.cfdGroup, stat, stackAccessor(stat))
                        });
                            
                        self.chart.render();
                        
                        self.isReady = true;
                    });
                },

                reset: function() {
                    this.set('isReady', false);
                    this.set('errorMessage', '');

                    if (!_.isEmpty(this.chart)) {
                        dc.deregisterChart(this.chart);
                        this.set('chart', {});
                    }
                },

                handleErrors: function(error, cfdData) {
                    if(error) {
                        this.set('errorMessage', error.message);
                        return true;
                    }
                    if(!Object.keys(cfdData.dataByStatus).length) {
                        this.set('errorMessage', 'Impossible to generate CFD. No data for this project.');
                        return true;
                    }

                    return false;
                },
                
                createChart: function() {
                    var chart = dc.lineChart("#cfd");

                    // basic chart configuration
                    chart
                        .margins({top: 0, right: 0, bottom: 60, left: 200})
                        .legend(
                            dcUtils.getDefaultLegend()
                        )
                        .colors(
                            dcUtils.getDefaultColors()
                        )
                        .renderArea(true)
                        .brushOn(false)       // don't select with drag-n-drop
                        .mouseZoomable(true)  // zoom with mouse wheel
                        .elasticY(true)       // y axis will adjust to the data
                        .xAxis()               
                            .tickFormat(function(v) { // formats the data in the X axis
                                return dcUtils.dateFormat(v);
                            });

                    chart.renderlet(function (chart) {
                        // rotate x-axis labels
                        chart.selectAll('g.x text')
                            .attr('transform', 'translate(-10,20) rotate(315)');
                    });

                    this.set('chart', chart);
                }
            });
        })();
    </script>
</dom-module>