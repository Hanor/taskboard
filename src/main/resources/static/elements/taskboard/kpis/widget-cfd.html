<!--
  [LICENSE]
  Taskboard
  ---
  Copyright (C) 2015 - 2016 Objective Solutions
  ---
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  [/LICENSE]
  -->
<dom-module id="widget-cfd">

    <template>

        <style>
        </style>

        <widget-wrap title="CFD" is-ready="{{isReady}}" options="{{options}}" chart="{{chart}}" error-message="{{errorMessage}}">

            <div id="cfd" class="tb-chart"></div>

            <wrap-modal title="Filters" class="filters-modal">
                <h3 class="tb-label">Issue Types</h3>
                <div class="config-slot-0 dc-chart--no-float"></div>
                <paper-button class="ok-button" on-tap="_closeFiltersModal">OK</paper-button>
            </wrap-modal>

        </widget-wrap>

    </template>

    <script>
        (function () {
            Polymer({
                is: 'widget-cfd',

                properties: {
                    selectedProjectKey: {
                        type: String,
                        notify: true
                    },
                    selectedDate: {
                        type: String,
                        notify: true,
                        value: '',
                    },
                    isReady: {
                        type: Boolean,
                        notify: true,
                        value: false
                    },
                    errorMessage: {
                        type: String,
                        notify: true,
                        value: ''
                    },
                    chart: {
                        type: Object,
                        notify: true,
                        value: function() { return {}; }
                    },
                    options: {
                        type: Array,
                        readOnly: true
                    }
                },

                observers: [
                    '_onProjectSelected(selectedProjectKey, selectedDate)',
                ],

                ready: function() {
                    this._setOptions([
                        {
                            icon:'taskboard-icons:dashboard-filter'
                            , title: 'Filters'
                            , tap: this._openFiltersModal.bind(this)
                            , cssClasses: ''
                        }
                    ]);
                },

                _onProjectSelected: function(selectedProjectKey, selectedDate) {
                    this.loadCfdChart(selectedProjectKey);
                },

                groupByDate: function(cfdData) {
                    var status = Object.keys(cfdData.dataByStatus).reverse();
                    var graphData = [];
                    // regroup based on date
                    status.forEach(function(stat) {
                        cfdData.dataByStatus[stat].forEach(function(d) {
                            graphData.push({
                                date: new Date(d.date),
                                status: stat,
                                count: d.count,
                                issueType: d.type
                            });
                        })
                    });

                    return graphData;
                },

                loadCfdChart: function(project) {
                    this.reset();

                    var self = this;

                    self.xhr = d3.json("/api/projects/"+ project + "/followup/cfd", function(error, cfdData) {
                        if(self.handleErrors(error, cfdData))
                            return;

                        var status = Object.keys(cfdData.dataByStatus).reverse();

                        self.cfdData = self.groupByDate(cfdData);
                        var startDate = self.cfdData[0].date;
                        var endDate = self.cfdData[self.cfdData.length-1].date;

                        self.ndx = crossfilter(self.cfdData);
                        // the (run) dimension is the dimension on which dc will iterate and will become the "X" axis
                        self.cfdDim = self.ndx.dimension(function(d) {
                            return d.date;
                        });

                        function compose(p, v, signal){
                            if (!p.plotData)
                                p.plotData = {}

                            if (!p.plotData[v.status])
                                p.plotData[v.status] = 0;

                            p.plotData[v.status] += signal * v.count;
                            return p;
                        }

                        self.cfdGroup = self.cfdDim.group()
                            .reduce(function(p, v) {
                                    return compose(p, v, 1)
                                },
                                function(p, v) {
                                    return compose(p, v, -1)
                                },
                                function() {
                                    return {plotData:{}};
                                }
                            );

                        self.createChart(startDate, endDate);
                        self.createIssueListFilter();

                        // function to access correct data for each stack
                        function stackAccessor(status) {
                            return function(d) {
                                return d.value.plotData[status];
                            };
                        }

                        var xScale = d3.time.scale().domain([startDate, endDate]);
                        self.chart
                            .dimension(self.cfdDim)
                            .group(self.cfdGroup, status[0], stackAccessor(status[0])) // the first stack must be added as a group
                            .x(xScale);

                        status.forEach(function(stat) {
                            // stackTitle(stat) generates a callback to generate the label for points in this stack
                            self.chart.title(stat, function (d){
                                var label = d.key.toLocaleDateString() + "\n\n";
                                var total = 0;
                                label +="** " + stat +": "+d.value.plotData[stat]+ " **\n";
                                Object.keys(d.value.plotData).reverse().forEach(function(key) {
                                    if (key !== stat)
                                        label += key+": "+d.value.plotData[key]+ "\n";
                                    total += d.value.plotData[key];
                                });
                                return label+="\nTotal: " + total;
                            });
                        });

                        // remove the first status because it was already added in the "group" invocation above
                        status = status.splice(1);

                        // add the other stacks, one for each remaining status
                        status.forEach(function(stat) {
                            // stack the status data; stackAccessor(stat) generates a callback that tells dc how to read this stack data
                            self.chart.stack(self.cfdGroup, stat, stackAccessor(stat))
                        });

                        self.chart.__legendables = self.chart.legendables;
                        self.chart.legendables = function() {
                            var items = self.chart.__legendables();
                            return items.reverse();
                        };

                        self.chart.render();

                        self.isReady = true;
                    });
                },

                reset: function() {
                    this.set('isReady', false);
                    this.set('errorMessage', '');
                    this.set('options.0.cssClasses', '');

                    if (this.xhr) {
                        this.xhr.abort();
                        this.xhr = null;
                    }
                    if (!_.isEmpty(this.chart)) {
                        dc.deregisterChart(this.chart);
                        this.set('chart', {});
                    }
                    if (this.issueListFilter) {
                        dc.deregisterChart(this.issueListFilter);
                        delete this.issueListFilter;
                    }
                },

                handleErrors: function(error, cfdData) {
                    if(error) {
                        this.set('errorMessage', error.message);
                        return true;
                    }
                    if(!Object.keys(cfdData.dataByStatus).length) {
                        this.set('errorMessage', 'Impossible to generate CFD. No data for this project.');
                        return true;
                    }

                    return false;
                },

                createChart: function(startDate, endDate) {
                    var chart = dc.lineChart("#cfd");

                    // basic chart configuration
                    chart
                        .margins({top: 20, right: 30, bottom: 60, left: 200})
                        .legend(
                            dcUtils.getDefaultLegend()
                        )
                        .colors(
                            dcUtils.getDefaultColors()
                        )
                        .renderArea(true)
                        .brushOn(false)       // don't select with drag-n-drop
                        .mouseZoomable(false)  // zoom with mouse wheel
                        .elasticY(true)       // y axis will adjust to the data
                        .xAxis()
                            .tickValues(
                                dcUtils.getDateTicks(startDate, endDate, 14)
                            )
                            .tickFormat(function(v) {
                                return dcUtils.dateFormat(v);
                            });

                    dcUtils.rotateDateFormattedXAxis(chart);

                    this.set('chart', chart);
                },

                createIssueListFilter: function() {
                    var div = this.$$('.config-slot-0');
                    var list = dc.paperList(div);

                    this.typeDim = this.ndx.dimension(function(d) {
                        return d.issueType;
                    });
                    this.typeGroup = this.typeDim.group();

                    list
                        .dimension(this.typeDim)
                        .group(this.typeGroup)
                        .multiple(true)
                        .title(function(d) {
                            return d.key;
                        })
                        .promptValue('-none-')
                        .promptText('All Issues');

                    var all = list.data().map(list.keyAccessor());
                    list.replaceFilter([all]);

                    list.render();

                    var highlightButton = function() {
                        this.set('options.0.cssClasses', list.isAllSelected() ? '' : 'widget__button_highlighted');
                    }.bind(this);
                    list.on('filtered', highlightButton);

                    this.issueListFilter = list;
                },

                _openFiltersModal: function() {
                    this.$$('.filters-modal').open();
                },

                _closeFiltersModal: function() {
                    this.$$('.filters-modal').close();
                }
            });
        })();
    </script>
</dom-module>